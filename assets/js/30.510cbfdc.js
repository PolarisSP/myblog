(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{588:function(a,t,s){"use strict";s.r(t);var n=s(4),e=Object(n.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[a._v("#")]),a._v(" 概述")]),a._v(" "),s("p",[a._v("数据库锁设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构。\n根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类。")]),a._v(" "),s("h3",{attrs:{id:"全局锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#全局锁"}},[a._v("#")]),a._v(" 全局锁")]),a._v(" "),s("p",[a._v("全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。\n全局锁的典型使用场景是，做全库逻辑备份。但存在一个问题，在备份过程中整个库完全处于只读状态。")]),a._v(" "),s("p",[a._v("解决办法：官方自带的逻辑备份工具是 mysqldump。当 mysqldump 使用参数–single-transaction 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。")]),a._v(" "),s("h3",{attrs:{id:"表级锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#表级锁"}},[a._v("#")]),a._v(" 表级锁")]),a._v(" "),s("p",[a._v("MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。\n表锁的语法是 lock tables … read/write。与 FTWRL 类似，可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。\n另一类表级的锁是 MDL（metadata lock)。MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性。\n在 MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。")]),a._v(" "),s("div",{staticClass:"custom-block danger"},[s("p",{staticClass:"title"}),s("p",[a._v("如何安全地给小表加字段？")]),a._v(" "),s("p",[a._v("首先我们要解决长事务，事务不提交，就会一直占着 MDL 锁。在 MySQL 的 information_schema 库的 innodb_trx 表中，你可以查到当前执行中的事务。如果你要做 DDL 变更的表刚好有长事务在执行，要考虑先暂停 DDL，或者 kill 掉这个长事务。\n但考虑一下这个场景。如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而你不得不加个字段，你该怎么做呢？")]),a._v(" "),s("p",[a._v("这时候 kill 可能未必管用，因为新的请求马上就来了。比较理想的机制是，在 alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者 DBA 再通过重试命令重复这个过程。")]),a._v(" "),s("p",[a._v("MariaDB 已经合并了 AliSQL 的这个功能，所以这两个开源分支目前都支持 DDL NOWAIT/WAIT n 这个语法。")]),a._v(" "),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("ALTER TABLE tbl_name NOWAIT add column ...\nALTER TABLE tbl_name WAIT N add column ... \n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br")])])]),s("h3",{attrs:{id:"行级锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#行级锁"}},[a._v("#")]),a._v(" 行级锁")]),a._v(" "),s("p",[a._v("MySQL 的行锁是在引擎层由各个引擎自己实现的。InnoDB 是支持行锁的。\n在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。\n知道了这个设定，对我们使用事务有什么帮助呢？那就是，如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。")]),a._v(" "),s("h3",{attrs:{id:"死锁和死锁检测"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#死锁和死锁检测"}},[a._v("#")]),a._v(" 死锁和死锁检测")]),a._v(" "),s("p",[a._v("当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。")]),a._v(" "),s("p",[s("img",{attrs:{src:"/myblog/images/mysql/%E6%AD%BB%E9%94%81%E4%B8%BE%E4%BE%8B.jpg",alt:"死锁举例"}})]),a._v(" "),s("p",[a._v("出现死锁以后，有两种策略：")]),a._v(" "),s("ul",[s("li",[a._v("一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置。")]),a._v(" "),s("li",[a._v("另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。")])]),a._v(" "),s("p",[a._v("对于第一种策略，默认值为50S，当出现死锁时，第一个被锁住的线程要50S才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，是无法接受的。如果设置时间过短，出现死锁时，可以很快解除，但如果是简单的锁等待，就会出现很多误伤。\n所以正常情况下一般采用第二种策略。即：主动死锁检测。但仍存在一个问题：你可以想象一下这个过程：每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。\n那如果是我们上面说到的所有事务都要更新同一行的场景呢？\n每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是 O(n) 的操作。假设有 1000 个并发线程要同时更新同一行，那么死锁检测操作就是 100 万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的 CPU 资源。因此，你就会看到 CPU 利用率很高，但是每秒却执行不了几个事务。\n怎么解决由这种热点行更新导致的性能问题呢？\n问题的症结在于死锁检测需要耗费大量CPU资源，一种方式是关掉死锁检测，可是这种方式有一定的风险，一般出现死锁就回滚，然后业务重试就没问题了；而关掉死锁检测就意味可能出现大量的超时，对业务有损。\n另一种方式是控制并发度，如同一行同时最多只有10个线程在更新")]),a._v(" "),s("h2",{attrs:{id:"小结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[a._v("#")]),a._v(" 小结")]),a._v(" "),s("p",[a._v("全局锁主要用在逻辑备份过程中。对于全部是 InnoDB 引擎的库，我建议你选择使用–single-transaction 参数，对应用会更友好。")]),a._v(" "),s("p",[a._v("表锁一般是在数据库引擎不支持行锁的时候才会被用到的。\nMDL 会直到事务提交才释放，在做表结构变更的时候，你一定要小心不要导致锁住线上查询和更新。")]),a._v(" "),s("p",[a._v("MDL锁作用是防止DDL和DML并发的冲突")]),a._v(" "),s("p",[a._v("两阶段协议为起点，讨论了在开发的时候如何安排正确的事务语句。这里的原则是：如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁的申请时机尽量往后放。\n但是，调整语句顺序并不能完全避免死锁。所以我们引入了死锁和死锁检测的概念，以及提供了三个方案，来减少死锁对数据库的影响。减少死锁的主要方向，就是控制访问相同资源的并发事务量。")])])}),[],!1,null,null,null);t.default=e.exports}}]);